% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/env.R
\name{env}
\alias{env}
\alias{env.default}
\alias{env.environment}
\alias{env.formula}
\alias{env.frame}
\alias{env.function}
\alias{env_new}
\alias{env_next}
\alias{env_set}
\alias{env_set.environment}
\alias{env_set.formula}
\alias{env_set.function}
\alias{env_set_next}
\alias{env_tail}
\title{Get or set an environment.}
\usage{
env(env)

\method{env}{function}(env)

\method{env}{formula}(env)

\method{env}{frame}(env)

\method{env}{environment}(env)

\method{env}{default}(env)

env_set(env, new_env)

\method{env_set}{function}(env, new_env)

\method{env_set}{formula}(env, new_env)

\method{env_set}{environment}(env, new_env)

env_set_next(env, parent)

env_new(parent = env_caller(), dict = list())

env_next(env, n = 1)

env_tail(env)
}
\arguments{
\item{env}{An environment or an object associated with an
environment (i.e., an object with an \code{env()} method
defined).}

\item{new_env}{An environment to replace \code{env}.}

\item{parent}{A parent environment.}

\item{dict}{A vector with unique names which defines bindings
(pairs of name and value). See \code{\link{is_dict}()}.}

\item{n}{The number of generations to go through.}
}
\description{
Environments are objects that create a scope for evaluation of R
code. The reification of scope is one of the most powerful feature
of the R language. It allows you to change what a function or
expression sees when it is evaluated. Each environment is defined
with a parent environment. An environment and its grand-parents
form together a linear hierarchy: the objects within the
grand-parents are in scope unless they are eclipsed by bindings
with the same names in child environments.
}
\details{
\code{env()} and \code{env_set()} are s3 generics. Methods are
provided for functions, formulas and frames. They also work with
environments as this can simplify code in some situations.
\code{env_set()} does not work by side effect. The input is copied
before being assigned an environment, and left unchanged. However,
\code{env_set_next()} operates the inner environment which has a
side effect.

\code{env_new()} creates a new environment. \code{env_next()}
returns the parent environment of \code{env} if called with \code{n
= 1}, the grand-parent with \code{n = 2}, etc. \code{env_tail()}
searches through the parents for the one which hase
\code{\link{env_empty}()} as parent.
}
\examples{
# Get the environment of frame objects:
fn <- function() {
  list(
    env(call_frame()),
    environment()
  )
}
fn()

# Environment of closure functions:
env(fn)

# There is also an assignment operator:
env(fn) <- baseenv()
env(fn)

# Or equivalently:
fn <- env_set(fn, globalenv())
env(fn)


# Create a new environment with a given scope by setting a parent:
env <- env_new(parent = baseenv())
env_sees(env, "lapply")

# Use the empty environment if the environment should not have
# anything in scope:
env <- env_new(parent = env_empty())
env_sees(env, "lapply")


# Get the parent environment with env_next():
env_next(env_global())

# Or the tail environment with env_tail():
env_tail(env_global())
}
\seealso{
\link{env_scoped}, \code{\link{env_has}()},
  \code{\link{env_assign}()}.
}

