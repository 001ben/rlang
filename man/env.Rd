% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/env.R
\name{env}
\alias{env}
\alias{env.default}
\alias{env.environment}
\alias{env.formula}
\alias{env.frame}
\alias{env.function}
\alias{env_new}
\alias{env_parent}
\alias{env_tail}
\title{Get an environment.}
\usage{
env(env = env_caller())

\method{env}{function}(env = env_caller())

\method{env}{formula}(env = env_caller())

\method{env}{frame}(env = env_caller())

\method{env}{environment}(env = env_caller())

\method{env}{default}(env = env_caller())

env_new(parent = env_caller(), dict = list())

env_parent(env = env_caller(), n = 1)

env_tail(env = env_caller())
}
\arguments{
\item{env}{An environment or an object with a S3 method for
\code{env()}. If missing, the environment of the current
evaluation frame is returned.}

\item{parent}{A parent environment. Can be an object with a S3
method for \code{env()}.}

\item{dict}{A vector with unique names which defines bindings
(pairs of name and value). See \code{\link{is_dict}()}.}

\item{n}{The number of generations to go through.}
}
\description{
Environments are objects that create a scope for evaluation of R
code. Reification of scope is one of the most powerful feature of
the R language: it allows you to change what objects a function or
expression sees when it is evaluated. In R, scope is hierarchical:
each environment is defined with a parent environment. An
environment and its grandparents form together a linear
hierarchy. All objects within the grandparents are in scope unless
they are eclipsed by synonyms (other bindings with the same names)
in child environments.
}
\details{
\code{env()} is a s3 generic. Methods are provided for functions,
formulas and frames. If called with a missing argument, the
environment of the current evaluation frame (see
\code{\link{eval_stack}()}) is returned. If you call \code{env()}
with an environment, it acts as the identity function and the
environment is simply returned (this helps simplifying code when
writing generic functions).

\code{env_new()} creates a new environment. \code{env_parent()}
returns the parent environment of \code{env} if called with \code{n
= 1}, the grandparent with \code{n = 2}, etc. \code{env_tail()}
searches through the parents and returns the one which has
\code{\link{env_empty}()} as parent.
}
\examples{
# Get the environment of frame objects. If no argument is supplied,
# the current frame is used:
fn <- function() {
  list(
    env(call_frame()),
    env()
  )
}
fn()

# Environment of closure functions:
env(fn)

# There is also an assignment operator:
env(fn) <- env_base()
env(fn)


# env_new() creates by default an environment whose parent is the
# current environment. Here we return a new environment that has
# the evaluation environment (or frame environment) of a function
# as parent:
fn <- function() {
  my_object <- "A"
  env_new()
}
frame_env <- fn()

# The new environment is empty:
env_has(frame_env, "my_object")

# But sees objects defined inside fn() by inheriting from its
# parent:
env_sees(frame_env, "my_object")


# Create a new environment with a particular scope by setting a
# parent. When inheriting from the empty environment, the
# environment will have no object in scope at all:
env <- env_new(env_empty())
env_sees(env, "lapply")

# The base package environment is often a good default choice for a
# parent environment because it contains all standard base
# functions. Also note that it will never inherit from other loaded
# package environments since R keeps the base package at the tail
# of the search path:
env <- env_new(env_base())
env_sees(env, "lapply")

# Note that all other package environments inherit from env_base()
# as well:
env <- env_new(env_package("rlang"))
env_sees(env, "env_sees")
env_sees(env, "lapply")


# Get the parent environment with env_parent():
env_parent(env_global())

# Or the tail environment with env_tail():
env_tail(env_global())


# By default, env_parent() returns the parent environment of the
# current evaluation frame. If called at top-level (the global
# frame), the following two expressions are equivalent:
env_parent()
env_parent(env_global())

# This default is more handy when called within a function. In this
# case, the enclosure environment of the function is returned
# (since it is the parent of the evaluation frame):
enclos_env <- env_new()
fn <- with_env(enclos_env, function() env_parent())
identical(enclos_env, fn())
}
\seealso{
\link{env_scoped}, \code{\link{env_has}()},
  \code{\link{env_assign}()}.
}

