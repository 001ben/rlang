% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tidy-capture.R
\name{tidy_dots}
\alias{tidy_dots}
\alias{tidy_dots_alt}
\title{Capture dots.}
\usage{
tidy_dots(...)

tidy_dots_alt(...)
}
\arguments{
\item{...}{Arguments to capture.}
}
\description{
This set of functions are like \code{\link{tidy_capture}()} but for
\code{...} arguments. They capture expressions passed through dots
along their dynamic environments, and return them bundled as a set
of formulas. They differ in their treatment of pattern expressions
of the type \code{var := expr}.
}
\details{
\describe{
 \item{\code{tidy_dots()}}{
   When \code{:=} patterns are supplied to \code{tidy_dots()}, they
   are treated as a synonym of argument assignment \code{=}. On the
   other hand, they allow unquoting operators on the left-hand side,
   which makes it easy to assign names programmatically.}
 \item{\code{tidy_dots_alt()}}{
   It behaves similarly to \code{tidy_dots()} but returns the tidy
   quotes in a list with two components: \code{dots} and
   \code{alts}. Expressions supplied with \code{=} are returned in
   \code{dots} while those specified with \code{:=} end up in
   \code{alts}. This is useful for DSLs that treat patterns with a
   special meaning, such as ggvis. A downside of this approach is
   that non-patterned expressions cannot have their LHS
   interpolated.}
 \item{\code{tidy_patterns()}}{
   This dots capturing function returns patterns as is. Unquote
   operators are processed on capture, in both the LHS and the
   RHS. Unlike \code{tidy_dots()} and \code{tidy_dots_alt()},
   \code{tidy_patterns()} allows named patterns.}
}
}
\examples{
# While tidy_capture() only work for the most direct calls, that's
# not the case for tidy_dots(). Dots are forwarded all the way to
# tidy_dots() and can be captured across multiple layers of calls:
fn <- function(...) tidy_dots(y = a + b, ...)
fn(z = a + b)

# However if you pass a named argument in dots, only the expression
# at the innermost call site is captured:
fn <- function(...) tidy_dots(x = x)
fn(x = a + b)


# Dots can be spliced in:
args <- list(x = 1:3, y = ~var)
tidy_dots(!!! args, z = 10L)

# Raw expressions are turned to formulas:
args <- alist(x = foo, y = bar)
tidy_dots(!!! args)


# Patterns are treated similarly to named arguments:
tidy_dots(x := expr, y = expr)

# However, the LHS of patterns can be unquoted. The return value
# must be a symbol or a string:
var <- "foo"
tidy_dots(!!var := expr)

# If your DSL treats patterns specially, you can use
# tidy_dots_alt(). It also interpolates the LHS, but it returns a
# list of dots and alternatives:
tidy_dots_alt(!!var := expr, x := expr, y = expr)

# If you need the full LHS expression, use tidy_patterns():
tidy_patterns(var = foo(baz) := bar(baz))
}

