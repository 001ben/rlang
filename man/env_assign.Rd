% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/env.R
\name{env_assign}
\alias{env_assign}
\alias{env_bind}
\alias{env_define}
\title{Assign objects to an environment.}
\usage{
env_assign(env, nm, x)

env_bind(env, dict = list())

env_define(env, ...)
}
\arguments{
\item{env}{An environment or an object associated with an
environment (i.e., an object with an \code{env()} method
defined).}

\item{nm}{The name of the binding.}

\item{x}{The value of the binding.}

\item{dict}{A vector with unique names which defines bindings
(pairs of name and value). See \code{\link{is_dict}()}.}

\item{...}{Pairs of unique names and R objects used to define new
bindings.}
}
\value{
The input object \code{env}, with its associated
  environment modified in place.
}
\description{
These functions create bindings in the specified environment. The
bindings are supplied as pairs of names and values, either directly
(\code{env_assign()}), in dots (\code{env_define()}), or from a
dictionary (\code{env_bind()}). See \code{\link{is_dict}()} for
the definition of a dictionary.
}
\details{
Functions prefixed with \code{env_} operate by side effect. If you
assign bindings to a closure function, the environment of the
function is modified in place.
}
\examples{
# Create a function that uses undefined bindings:
fn <- function() list(a, b, c, d, e)
env(fn) <- env_new(env_scope_base())

# This would throw a scoping error if run:
# fn()

dict <- stats::setNames(letters, letters)
env_bind(fn, dict)

# fn() now sees the objects
fn()

# Redefine new bindings:
fn <- env_assign(fn, "a", "1")
fn <- env_define(fn, b = "2", c = "3")
fn()
}

