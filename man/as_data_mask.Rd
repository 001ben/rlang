% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval-tidy.R
\name{as_data_mask}
\alias{as_data_mask}
\alias{as_data_pronoun}
\alias{new_data_mask}
\alias{data_mask_clean}
\title{Create a data mask}
\usage{
as_data_mask(data, parent = base_env())

as_data_pronoun(data)

new_data_mask(bottom, top = NULL, parent = base_env())

data_mask_clean(mask)
}
\arguments{
\item{data}{A data frame or named vector of masking data.}

\item{parent}{The parent environment of the data mask.}

\item{bottom}{This is the environment (or the bottom of a set of
environments) containing definitions for overscoped symbols. The
bottom environment typically contains pronouns (like \code{.data})
while its direct parents contain the overscoping bindings. The
last one of these parents is the \code{top}.}

\item{top}{The top environment of the overscope. During tidy
evaluation, this environment is chained and rechained to lexical
enclosures of self-evaluating formulas (or quosures). This is the
mechanism that ensures hygienic scoping: the bindings in the
overscope have precedence, but the bindings in the dynamic
environment where the tidy quotes were created in the first place
are in scope as well. If \code{NULL} (the default), \code{bottom} is also the top of
the overscope.}

\item{mask}{A data mask as created by \code{as_data_mask()} or
\code{new_data_mask()}.}
}
\value{
An overscope environment.

A valid overscope: a child environment of \code{bottom}
containing the definitions enabling tidy evaluation
(self-evaluating quosures, formula-unguarding, ...).
}
\description{
Tidy evaluation works by rescoping a set of symbols (column names
of a data frame for example) to custom bindings. While doing this,
it is important to keep the original environment of captured
expressions in scope. The gist of tidy evaluation is to create a
dynamic scope containing custom bindings that should have
precedence when expressions are evaluated, and chain this scope
(set of linked environments) to the lexical enclosure of formulas
under evaluation. During tidy evaluation, formulas are transformed
into formula-promises and will self-evaluate their RHS as soon as
they are called. The main trick of tidyeval is to consistently
rechain the dynamic scope to the lexical enclosure of each tidy
quote under evaluation.
}
\details{
These functions are useful for embedding the tidy evaluation
framework in your own DSLs with your own evaluating function. They
let you create a custom dynamic scope. That is, a set of chained
environments whose bottom serves as evaluation environment and
whose top is rechained to the current lexical enclosure. But most
of the time, you can just use \code{\link[=eval_tidy_]{eval_tidy_()}} as it will take
care of installing the tidyeval components in your custom dynamic
scope.
\itemize{
\item \code{as_data_mask()} is the function that powers \code{\link[=eval_tidy]{eval_tidy()}}. It
could be useful if you cannot use \code{eval_tidy()} for some reason,
but serves mostly as an example of how to build a dynamic scope
for tidy evaluation. In this case, it creates pronouns \code{.data}
and \code{.env} and buries all dynamic bindings from the supplied
\code{data} in new environments.
\item \code{new_overscope()} is called by \code{as_data_mask()} and
\code{\link[=eval_tidy_]{eval_tidy_()}}. It installs the definitions for making
formulas self-evaluate and for formula-guards. It also installs
the pronoun \code{.top_env} that helps keeping track of the boundary
of the dynamic scope. If you evaluate a tidy quote with
\code{\link[=eval_tidy_]{eval_tidy_()}}, you don't need to use this.
\item \code{eval_tidy_()} is useful when you have several quosures to
evaluate in a same dynamic scope. That's a simple wrapper around
\code{\link[=eval_bare]{eval_bare()}} that updates the \code{.env} pronoun and rechains the
dynamic scope to the new formula enclosure to evaluate.
\item Once an expression has been evaluated in the tidy environment,
it's a good idea to clean up the definitions that make
self-evaluation of formulas possible \code{data_mask_clean()}.
Otherwise your users may face unexpected results in specific
corner cases (e.g. when the evaluation environment is leaked, see
examples). Note that this function is automatically called by
\code{\link[=eval_tidy_]{eval_tidy_()}}.
}
}
\section{Life cycle}{


In early versions of rlang data masks were called overscopes. We
think data mask is a more natural name in R. It makes reference to
masking in the search path which occurs through the same mechanism
(in technical terms, lexical scoping with hierarchically nested
environments). We say that that objects from user data mask objects
in the current environment.

Following this change in terminology, \code{as_data_mask()} and
\code{new_overscope()} were soft-deprecated in rlang 0.2.0 in favour of
\code{as_data_mask()} and \code{new_data_mask()}.
}

\examples{
# Evaluating in a tidy evaluation environment enables all tidy
# features:
mask <- as_data_mask(mtcars)
eval_tidy(quo(letters), mask)

# However you need to clean up the environment after evaluation.
data_mask_clean(mask)
}
