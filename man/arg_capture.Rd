% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/arg.R, R/dots.R
\name{arg_capture}
\alias{arg_capture}
\alias{dots_capture}
\title{Capture an expression and evaluation environment.}
\usage{
arg_capture(x)

dots_capture(...)
}
\arguments{
\item{x, ...}{Arguments to capture.}
}
\value{
\code{arg_capture()} returns a formula; \code{dots_capture()}
  returns a list of formulas, one for each dotted argument.
}
\description{
A powerful feature in R is the ability of capturing the expression
supplied in a function call. Once captured, this expression can be
inspected and evaluated, possibly within an altered scope
environment (for instance a scope where all elements of a data
frame are directly accessible). The tricky part of capturing an
expression for rescoping purposes is to keep the original
evaluation environment accessible so that other variables defined
at the call site are available when the expression gets
evaluated. It is thus necessary to capture not only the R
expression supplied as argument in a function call, but also the
evaluation environment of the call site. \code{arg_capture()} and
\code{dots_capture()} make it easy to record this information
within formulas.
}
\details{
The two main purposes for capturing arguments are labelling and
rescoping. With labelling, the normal R evaluation rules are kept
unchanged. The captured expression is only used to provide default
names (or labels) to output elements, such as column names for a
function that manipulates data frames or axis labels for a function
that creates graphics. In the case of rescoping however, evaluation
rules are altered. Functions that capture and rescope arguments are
said to use non-standard evaluation, or NSE. The approach we
recommend in rlang is to always create two versions of such
functions: a NSE version that captures arguments, and another that
work with captured arguments with standard evaluation rules (see
\code{decorate_nse()}). Providing a standard evaluation
version simplifies programming tasks. Also, it makes it possible to
forward named arguments across function calls (see below). See
\code{vignette("nse")} for more information on NSE.
}
\section{Forwarding arguments}{
 You have to be a bit careful when
  you pass arguments between introspective functions as only the
  most immediate call site is captured. For this reason, named
  arguments should be captured by an NSE function at the outermost
  level, and then passed around to SE versions that handle
  pre-captured arguments. See \code{\link{arg_info}()} for another
  approach to introspecting arguments with which it is possible to
  capture expressions at the outermost call site. This approach may
  be harder to reason about and has some limitations.

  Dots are different from named arguments in that they are
  implicitely forwarded. Forwarding dots does not create a new call
  site. The expression is passed on as is. That's why you can
  easily capture them with \code{\link[base]{substitute}()}. By the
  same token, you don't need to capture dots before passing them
  along in another introspective function. You do need to be a bit
  careful when you rescope expressions captured from dots because
  those expressions were not necessarily supplied in the last call
  frame. In general, the call site of argument passed through dots
  can be anywhere between the current and global frames. For this
  reason, it is recommended to always use \code{dots_capture()}
  rather than \code{substitute()} and \code{env_caller()} or
  \code{parent.frame()}, since the former will encode the
  appropriate evaluation environments within the formulas.
}
\examples{
# arg_capture() returns a formula:
fn <- function(foo) arg_capture(foo)
fn(a + b)

# Capturing an argument only works for the most direct call:
g <- function(bar) fn(bar)
g(a + b)


# Dots on the other hand are forwarded all the way to
# dots_capture() and can be captured across levels:
fn <- function(...) dots_capture(y = a + b, ...)
fn(z = a + b)

# Note that if you pass a named argument in dots, only the
# expression at the dots call site is captured:
fn <- function(x = a + b) dots_capture(x = x)
fn()
}
\seealso{
\code{\link{arg_expr}()}, \code{\link{arg_label}()} and
  \code{\link{arg_text}()} provide labelling information in
  alternative forms.
}

