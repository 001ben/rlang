% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/eval.R
\name{eval_bare}
\alias{eval_bare}
\title{Evaluate an expression in an environment}
\usage{
eval_bare(expr, env = parent.frame())
}
\arguments{
\item{expr}{An expression to evaluate.}

\item{env}{The environment in which to evaluate the expression.}
}
\description{
\code{eval_bare()} is a lower-level version of function \code{\link[base:eval]{base::eval()}}.
Technically, it is a simple wrapper around the C function
\code{Rf_eval()}. It has different evaluation semantics than \code{eval()}.
\itemize{
\item It does not accept auxiliary data and has no \code{data} argument.
\item It can't evaluate \code{break} or \code{next} expressions even if called
within a loop.
\item It evaluates \code{return()} calls in frame environments on the call
stack. This causes a long return that might unwind multiple
frames (triggering the \code{on.exit()} event for each frame).
\item Similarly, it evaluates stack-sensitive calls like
\code{parent.frame()}, \code{sys.call()}, and generally all the \code{sys.xxx()}
functions for stack inspection in the actual frame environments.
This is similar to how this type of calls can be evaluated deep
in the call stack because of lazy evaluation.
\item It only creates one frame on the call stack.
}

The last property is why the stack-sensitive functions are
evaluated in the correct frame environments. \code{base::eval()} creates
two call frames, the second of which has the user-supplied
environment as frame environment.  This means that if you supply an
existing frame environment to \code{base::eval()} you create a duplicate
frame on the stack that confuses stack-sensitive functions. We call
these evaluation semantics "stack inconsistent".
}
\examples{
# eval_bare() works just like base::eval() but you have to create
# the evaluation environment yourself:
eval_bare(quote(foo), env(foo = "bar"))

# eval() has different evaluation semantics than eval_bare(). It
# can return from the supplied environment even if its an
# environment that is not on the call stack (i.e. because you've
# created it yourself). The following would trigger an error with
# eval_bare():
ret <- quote(return("foo"))
eval(ret, env())
# eval_bare(ret, env())  # "no function to return from" error

# Another feature of eval() is that you can control surround loops:
bail <- quote(break)
while (TRUE) {
  eval(bail)
  # eval_bare(bail)  # "no loop for break/next" error
}

# To explore the consequences of stack inconsistent semantics, let's
# create a function that evaluates `parent.frame()` deep in the call
# stack, in an environment corresponding to a frame in the middle of
# the stack. For consistency we R's lazy evaluation semantics, we'd
# expect to get the caller of that frame as result:
fn <- function(eval_fn) {
  list(
    returned_env = middle(eval_fn),
    actual_env = get_env()
  )
}
middle <- function(eval_fn) {
  deep(eval_fn, get_env())
}
deep <- function(eval_fn, eval_env) {
  expr <- quote(parent.frame())
  eval_fn(expr, eval_env)
}

# With eval_bare(), we do get the expected environment:
fn(rlang::eval_bare)

# But that's not the case with base::eval():
fn(base::eval)

# Another difference of eval_bare() compared to base::eval() is
# that it does not insert parasite frames in the evaluation stack:
get_stack <- quote(identity(ctxt_stack()))
eval_bare(get_stack)
eval(get_stack)
}
\seealso{
\code{\link[=eval_tidy]{eval_tidy()}} for evaluation with data mask and quosure
support.
}
