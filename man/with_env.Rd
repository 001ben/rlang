% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/env.R
\name{with_env}
\alias{with_env}
\title{Evaluate an expression within a given environment.}
\usage{
with_env(env, expr)
}
\arguments{
\item{env}{An environment within which to evaluate \code{expr}. Can
be an object with an \code{\link{env}()} method.}

\item{expr}{An expression to evaluate.}
}
\description{
This function evaluate \code{expr} within \code{env}. It uses
\code{\link{expr_eval}()} which features a lighter evaluation
mechanism than base R \code{\link[base]{eval}()}, and which also
has some subtle implications when evaluting stack sensitive
functions (see help for \code{\link{expr_eval}()}).
}
\examples{
# with_env() is handy to create formulas with a given environment:
f <- with_env(env, ~new_formula())
identical(f_env(f), env)

# Or functions with a given enclosure:
fn <- with_env(env, function() NULL)
identical(env(fn), env)


# Unlike eval() it doesn't create duplicates on the evaluation
# stack. You can thus use it e.g. to create non-local returns:
fn <- function() {
  g(env())
  "normal return"
}
g <- function(env) {
  with_env(env, return("early return"))
}
fn()


# Since env is passed to env(), it can be any object with an env()
# method. For strings, the env_package() is returned:
with_env("base", ~mtcars)
}

