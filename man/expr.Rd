% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/expr.R
\name{expr}
\alias{expr}
\alias{enexpr}
\alias{exprs}
\alias{enexprs}
\title{Raw quotation of an expression}
\usage{
expr(expr)

enexpr(arg)

exprs(..., .named = FALSE, .ignore_empty = c("trailing", "none", "all"),
  .unquote_names = TRUE)

enexprs(..., .named = FALSE, .ignore_empty = c("trailing", "none", "all"),
  .unquote_names = TRUE)
}
\arguments{
\item{expr}{An expression.}

\item{arg}{A symbol referring to an argument. The expression
supplied to that argument will be captured unevaluated.}

\item{...}{Arguments to extract.}

\item{.named}{Whether to ensure all dots are named. Unnamed
elements are processed with \code{\link[=expr_text]{expr_text()}} to figure out a default
name. If an integer, it is passed to the \code{width} argument of
\code{expr_text()}, if \code{TRUE}, the default width is used. See
\code{\link[=exprs_auto_name]{exprs_auto_name()}}.}

\item{.ignore_empty}{Whether to ignore empty arguments. Can be one
of \code{"trailing"}, \code{"none"}, \code{"all"}. If \code{"trailing"}, only the
last argument is ignored if it is empty.}

\item{.unquote_names}{Whether to treat \code{:=} as \code{=}. Unlike \code{=}, the
\code{:=} syntax supports \code{!!} unquoting on the LHS.}
}
\value{
The raw expression supplied as argument. \code{exprs()} returns
a list of expressions.
}
\description{
These functions return raw expressions (whereas \code{\link[=quo]{quo()}} and
variants return quosures). They support \link{quasiquotation}
syntax.
\itemize{
\item \code{expr()} returns its argument unevaluated. It is equivalent to
\code{\link[base:bquote]{base::bquote()}}.
\item \code{enexpr()} takes an argument name and returns it unevaluated. It
is equivalent to \code{\link[base:substitute]{base::substitute()}}. The variant \code{ensym()} also
checks the argument is a simple symbol.
\item \code{exprs()} and \code{enexprs()} capture multiple expressions and return
a list. \code{exprs()} can be used anywhere but \code{enexprs()} must be
used within a function. These functions capture arguments
contained in \code{...} the same way but treat other arguments
differently. \code{exprs()} captures whatever expression is supplied
(and is thus equivaluent to \code{\link[base:alist]{base::alist()}}) while \code{enexprs()}
takes argument names and captures the expressions supplied one
level up.
}

See \code{\link[=is_expression]{is_expression()}} for more about R expressions.
}
\examples{
# The advantage of expr() over quote() is that it unquotes on
# capture:
expr(list(1, !! 3 + 10))

# Unquoting can be especially useful for successive transformation
# of a captured expression:
(expr <- quote(foo(bar)))
(expr <- expr(inner(!! expr, arg1)))
(expr <- expr(outer(!! expr, !!! lapply(letters[1:3], as.symbol))))

# Unlike quo(), expr() produces expressions that can
# be evaluated with base::eval():
e <- quote(letters)
e <- expr(toupper(!!e))
eval(e)

# Be careful if you unquote a quosure: you need to take the RHS
# (and lose the scope information) to evaluate with eval():
f <- quo(letters)
e <- expr(toupper(!! get_expr(f)))
eval(e)

# On the other hand it's fine to unquote quosures if you evaluate
# with eval_tidy():
f <- quo(letters)
e <- expr(toupper(!! f))
eval_tidy(e)

# exprs() lets you unquote names with the definition operator:
nm <- "foo"
exprs(a = 1, !! nm := 2)
}
\seealso{
\code{\link[=quo]{quo()}}, \code{\link[=is_expression]{is_expression()}}
}
