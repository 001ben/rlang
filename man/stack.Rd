% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/stack.R
\name{stack}
\alias{call_depth}
\alias{call_frame}
\alias{call_stack}
\alias{eval_depth}
\alias{eval_frame}
\alias{eval_stack}
\alias{global_frame}
\alias{stack}
\title{Call stack information}
\usage{
global_frame()

eval_frame(n = 1)

call_frame(n = 1, clean = TRUE)

eval_depth()

call_depth()

eval_stack(n = NULL)

call_stack(n = NULL, clean = TRUE)
}
\arguments{
\item{n}{The number of frames to go back in the stack.}

\item{clean}{Whether to post-process the call stack to clean
non-standard frames. If \code{TRUE}, suboptimal call-stack
entries by \code{\link[base]{eval}()} and
\code{\link[base]{Recall}()} will be cleaned up: \code{Recall()}
frames will be assigned the correct parent and \code{eval()}
frames are merged together (as \code{eval()} creates a duplicate
frame).}
}
\description{
The \code{eval_} and \code{call_} families of functions provide a
replacement for the base R functions prefixed with \code{sys.}
(which are all about the context stack), as well as for
\code{\link{parent.frame}()} (which is the only base R function for
querying the call stack). The context stack includes all R-level
evaluation contexts. It is linear in terms of execution history but
due to lazy evaluation it is potentially nonlinear in terms of call
history. The call stack history, on the other hand, is homogenous.
See \code{vignette("stack")} for more information.
}
\details{
\code{eval_frame()} and \code{call_frame()} return a \code{frame}
object containing the following fields: \code{expr} and \code{env}
(call expression and evaluation environment), \code{pos} and
\code{caller_pos} (position of current frame in the context stack
and position of the caller), and \code{fun} (function of the
current frame). \code{eval_stack()} and \code{call_stack()} return
a list of all context or call frames on the stack. Finally,
\code{eval_depth()} and \code{call_depth()} report the current
context position or the number of calling frames on the stack.

The base R functions take two sorts of arguments to indicate which
frame to query: \code{which} and \code{n}. The \code{n} argument is
straightforward: it's the number of frames to go down the stack,
with \code{n = 1} referring to the current context. The
\code{which} argument is more complicated and changes meaning for
values lower than 1. For the sake of consistency, the lazyeval
functions all take the same kind of argument \code{n}. This
argument has a single meaning (the number of frames to go down the
stack) and cannot be lower than 1.

Note finally that \code{parent.frame(1)} corresponds to
\code{call_frame(2)$env}, as \code{n = 1} always refers to the
current frame. This makes the \code{_frame()} and \code{_stack()}
functions consistent: \code{eval_frame(2)} is the same as
\code{eval_stack()[[2]]}. Also, \code{eval_depth()} returns one
more frame than \code{\link[base]{sys.nframe}()} because it counts
the global frame. That is consistent with the \code{_stack()}
functions which return the global frame as well. This way,
\code{call_stack(call_depth())} is the same as
\code{global_frame()}.
}
\examples{
# Expressions within arguments count as contexts
identity(identity(eval_depth())) # returns 2

# But they are not part of the call stack because arguments are
# evaluated within the calling function (or the global environment
# if called at top level)
identity(identity(call_depth())) # returns 0

# The context stacks includes all intervening execution frames. The
# call stack doesn't:
f <- function(x) identity(x)
f(f(eval_stack()))
f(f(call_stack()))

g <- function(cmd) cmd()
f(g(eval_stack))
f(g(call_stack))

# The lazyeval _stack() functions return a list of frame
# objects. Use purrr::transpose() or index a field with
# purrr::map()'s to extract a particular field from a stack:
if (requireNamespace("purrr", quietly = TRUE)) {
  stack <- f(f(call_stack()))
  purrr::map(stack, "env")
  purrr::transpose(stack)$expr
}
}

