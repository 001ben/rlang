% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/lang.R
\name{is_lang}
\alias{is_lang}
\alias{is_language}
\alias{is_symbol}
\alias{is_parsable_literal}
\alias{is_symbolic}
\alias{is_pairlist}
\title{Is an object a language object?}
\usage{
is_lang(x)

is_language(x)

is_symbol(x)

is_parsable_literal(x)

is_symbolic(x)

is_pairlist(x)
}
\arguments{
\item{x}{An object to test. When you supply a tidy quote (see
\code{\link{tidy_quote}()}) to any of the language predicates,
they will perform their test on the RHS of the formula.}
}
\description{
These helpers are consistent wrappers around their base R
equivalents. \code{is_lang()} and its alias \code{is_language()}
test for language objects, the set of objects that can be obtained
from parsing R code. A language object can be one of two things:
either a symbolic object (for which \code{is_symbolic()} returns
\code{TRUE}), or a parsable literal (testable with
\code{is_parsable_literal()}).
}
\details{
Literals are the set of R objects that evaluate to themselves when
supplied to \code{eval()}. Non-literal objects are called symbolic.
Only symbols and calls are symbolic. They form the backbone of an
expression, and their values are looked up by the R interpreter
when the expression is evaluated. By contrast, literals are
returned as is. Scalar strings, numbers, booleans, and the
\code{NULL} object form a special subset of literals. They are the
only non-symbolic objects that can arise from parsing a string or
an R source file (e.g. from using \code{\link{parse_expr}()}). You
can test for them with \code{is_parsable_literal()}.

\code{is_parsable_literal()} is a predicate that returns
\code{TRUE} for the subset of literals that are created by R when
parsing text (see \code{\link{parse_expr}()}): numbers, strings and
\code{NULL}. Along with symbols, these literals are the
terminating nodes in a parse tree. Note that in the most general
sense, a literal is any R object that evaluates to itself and that
can be evaluated in the empty environment. For instance,
\code{quote(c(1, 2))} is not a literal, but the result of
evaluating it in \code{\link{base_env}()} is (in this case an
atomic vector).  Technically, this sort of literal objects can be
inlined in language expressions. If your function accepts arbitrary
expressions, it should thus account for that possibility with a
catch-all branch. On the other hand, if your function only gets
expressions created from a parse, \code{quote()}, or
\code{\link{tidy_capture}()}, then you can check for literals with
\code{is_parsable_literal()}.

Finally, pairlists can also be language objects. However, since
they are mostly an internal data structure, \code{is_lang()}
returns \code{FALSE} for pairlists. You can use
\code{is_pairlist()} to explicitly check for them. Pairlists are
the data structure for function arguments. They usually do not
arise from R code because subsetting a call is a type-preserving
operation. However, you can obtain the pairlist of arguments by
taking the CDR of the call object from C code. The rlang function
\code{\link{call_args_lsp}()} will do it from R. Another way in
which pairlist of arguments arise is by extracting the argument
list of a closure with \code{\link[base]{formals}()} or
\code{\link{fn_fmls}()}.
}
\examples{
q1 <- quote(1)
is_lang(q1)
is_parsable_literal(q1)

q2 <- quote(x)
is_lang(q2)
is_symbol(q2)

q3 <- quote(x + 1)
is_lang(q3)
is_call(q3)


# Since tidy quotes are an important way of representing
# expressions in R, all language predicates will test the RHS of
# the formula if you supply one:
is_symbol(~foo)
is_call(~foo)
is_symbol(~foo(bar))
is_call(~foo(bar))


# Atomic language objects are the terminating nodes of a call
# tree: NULL or a scalar atomic vector:
is_parsable_literal("string")
is_parsable_literal(NULL)

is_parsable_literal(letters)
is_parsable_literal(quote(call()))

# Parsable literals have the property of being self-quoting:
identical("foo", quote("foo"))
identical(1L, quote(1L))
identical(NULL, quote(NULL))

# Like any literals, they can be evaluated within the empty
# environment:
eval(quote(1L), empty_env())

# Whereas it would fail for symbolic language objects:
# eval(quote(c(1L, 2L)), empty_env())


# Pairlists are also language objects representing argument lists.
# You will usually encounter them with extracted formals:
fmls <- formals(is_lang)
typeof(fmls)

# Since they are mostly an internal data structure, is_lang()
# returns FALSE for pairlists, so you will have to check explicitly
# for them:
is_lang(fmls)
is_pairlist(fmls)

# Note that you can also extract call arguments as a pairlist:
call_args_lsp(quote(fn(arg1, arg2 = "foo")))
}
\seealso{
\code{\link{is_call}()} for a call predicate.
  \code{\link{as_name}()} and \code{\link{as_call}()} for coercion
  functions.
}
