% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/language.R
\name{is_lang}
\alias{is_lang}
\alias{is_literal}
\alias{is_name}
\alias{is_pairlist}
\alias{is_symbol}
\title{Is an object a language object?}
\usage{
is_lang(x)

is_name(x)

is_symbol(x)

is_pairlist(x)

is_literal(x)
}
\arguments{
\item{x}{An object to test.}
}
\description{
These helpers are consistent wrappers around their base R
equivalents. A language object is either an atomic vector
(typically a scalar), a name (aka a symbol), a call, or a pairlist
(used for function arguments).
}
\details{
\code{is_literal()} is a predicate that returns \code{TRUE} for the
subset of literals that are created by R when parsing text (see
\code{\link{parse_expr}()}): numbers, strings and \code{NULL}.
Along with symbols, these literals are the terminating nodes in a
parse tree. Note that in the most general sense, a literal is any R
object that evaluates to itself and that can be evaluated in the
empty environment. For instance, \code{quote(c(1, 2))} is not a
literal, but the result of evaluating it in
\code{\link{env_base}()} is (in this case an atomic vector).
Technically, this sort of literal objects can be inlined in
language expressions. If your function accepts arbitrary
expressions, it should thus account for that possibility with a
catch-all branch. On the other hand, if your function only gets
expressions created from a parse, \code{quote()}, or
\code{\link{arg_capture}()}, then you can check for literals with
\code{is_literal()}.

Finally, pairlists can also be language objects. This is the data
structure for function arguments. They usually do not arise from R
code because subsetting a call is a type-preserving
operation. However, you can obtain the pairlist of arguments by
taking the CDR of the call object from C code. The rlang function
\code{\link{call_args_lsp}()} will do it from R. Another way
in which pairlist of arguments arise is by extracting the argument
list of a closure with \code{\link[base]{formals}()} or
\code{\link{fn_fmls}()}.
}
\examples{
q1 <- quote(1)
is_lang(q1)
is_atomic(q1)

q2 <- quote(x)
is_lang(q2)
is_name(q2)

q3 <- quote(x + 1)
is_lang(q3)
is_call(q3)


# Atomic language objects are the terminating nodes of a call
# tree: NULL or a scalar atomic vector:
is_literal("string")
is_literal(NULL)

is_literal(letters)
is_literal(quote(call()))

# Literals have the property of being self-quoting:
identical("foo", quote("foo"))
identical(1L, quote(1L))
identical(NULL, quote(NULL))

# They can be evaluated within the empty environment:
eval(quote(1L), env_empty())

# Whereas it would fail for non-atomic language objects:
# eval(quote(c(1L, 2L)), env_empty())


# Pairlists are also language objects representing argument lists.
# You will usually encounter them with extracted formals:
fmls <- formals(is_lang)
typeof(fmls)
is_lang(fmls)

# You can also extract call arguments as a pairlist:
call_args_lsp(quote(fn(arg1, arg2 = "foo")))
}
\seealso{
\code{\link{is_call}()} for a call predicate.
  \code{\link{as_name}()} and \code{\link{as_call}()} for coercion
  functions.
}

