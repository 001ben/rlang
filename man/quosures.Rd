% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dots.R, R/quos.R
\name{dots_definitions}
\alias{dots_definitions}
\alias{quosures}
\alias{quos}
\alias{enquos}
\alias{is_quosures}
\title{Tidy quotation of multiple expressions and dots}
\usage{
dots_definitions(..., .named = FALSE)

quos(..., .named = FALSE, .ignore_empty = c("trailing", "none", "all"),
  .unquote_names = TRUE)

enquos(..., .named = FALSE, .ignore_empty = c("trailing", "none", "all"),
  .unquote_names = TRUE)

is_quosures(x)
}
\arguments{
\item{...}{For \code{enquos()}, names of arguments to capture without
evaluation (including \code{...}). For \code{quos()}, the expressions to
capture unevaluated (including expressions contained in \code{...}).}

\item{.named}{Whether to ensure all dots are named. Unnamed
elements are processed with \code{\link[=expr_text]{expr_text()}} to figure out a default
name. If an integer, it is passed to the \code{width} argument of
\code{expr_text()}, if \code{TRUE}, the default width is used. See
\code{\link[=exprs_auto_name]{exprs_auto_name()}}.}

\item{.ignore_empty}{Whether to ignore empty arguments. Can be one
of \code{"trailing"}, \code{"none"}, \code{"all"}. If \code{"trailing"}, only the
last argument is ignored if it is empty.}

\item{.unquote_names}{Whether to treat \code{:=} as \code{=}. Unlike \code{=}, the
\code{:=} syntax supports \code{!!} unquoting on the LHS.}

\item{x}{An object to test.}
}
\description{
\itemize{
\item \code{quos()} quotes its arguments and returns them as a list of
quosures (see \code{\link[=quo]{quo()}}).
\item \code{enquos()} should be used inside a function. It takes argument
names and captures the expressions to those arguments, i.e. one
level up.
}
}
\section{The }{
= operator:

Both \code{quos} and \code{dots_definitions()} have specific support for
definition expressions of the type \code{var := expr}, with some
differences:

\describe{
\item{\code{quos()}}{
When \code{:=} definitions are supplied to \code{quos()}, they are treated
as a synonym of argument assignment \code{=}. On the other hand, they
allow unquoting operators on the left-hand side, which makes it
easy to assign names programmatically.}
\item{\code{dots_definitions()}}{
This dots capturing function returns definitions as is. Unquote
operators are processed on capture, in both the LHS and the
RHS. Unlike \code{quos()}, it allows named definitions.}
}
}

\examples{
# quos() is like the singular version quo() but allows quoting
# several arguments:
quos(foo(), letters[1:2], !! letters[1:2])

# enquos() is like enquo() but lets you capture several arguments:
fn <- function(arg1, arg2, ...) {
  enquos(arg1, arg2, ...)
}
fn(leonardo, donatello, raphael())

# Because of the nature of dots forwarding (expressions are
# "teleported"), quos() can also be used to capture dots. But
# notice the difference with enquos(). Arguments other than `...`
# are captured directly, within the function:
fn <- function(arg1, arg2, ...) {
  quos(arg1, arg2, ...)
}
fn(leonardo, donatello, raphael())


# Lists of arguments can be spliced in:
args <- list(x = 1:3, y = ~var)
quos(!!! args, z = 10L)

# As well as lists of bare expressions (make sure that the current
# environment is where the symbols in these expressions are defined):
args <- alist(mouse1 = bernard, mouse2 = bianca)
quos(!!! args)


# Like `=`, the `:=` operator creates named arguments:
quos(mouse1 := bernard, mouse2 = bianca)

# The `:=` is mainly useful to unquote names. Unlike `=` it
# supports `!!` on its LHS:
var <- "unquote me!"
quos(!!var := bernard, mouse2 = bianca)


# All these features apply to dots captured by enquos():
fn <- function(...) enquos(...)
fn(
  !!! args,
  !!var := penny
)
}
