% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quasiquotation.R
\name{quasiquotation}
\alias{quasiquotation}
\alias{UQ}
\alias{UQE}
\alias{UQS}
\alias{UQ}
\alias{UQE}
\alias{UQS}
\alias{!!}
\alias{!!!}
\alias{:=}
\title{Quasiquotation of an expression}
\usage{
UQ(x)

UQE(x)

UQS(x)

"!!"(x)

":="(x, y)
}
\arguments{
\item{x}{An expression to unquote.}

\item{y}{An R expression that will be given the argument name
supplied to \code{x}.}
}
\description{
Quasiquotation is the mechanism that makes it possible to program
flexibly with
\href{http://rlang.tidyverse.org/articles/tidy-evaluation.html}{tidyeval}
grammars like dplyr. It is enabled in all tidyeval functions, the
most fundamental of which are \code{\link[=quo]{quo()}} and \code{\link[=expr]{expr()}}.

Quasiquotation is the combination of quoting an expression while
allowing immediate evaluation (unquoting) of part of that
expression. We provide both syntactic operators and functional
forms for unquoting.
\itemize{
\item The \code{!!} operator unquotes its argument. It gets evaluated
immediately in the surrounding context.
\item The \code{!!!} operator unquotes and splices its argument. The
argument should represents a list or a vector. Each element will
be embedded in the surrounding call, i.e. each element is
inserted as an argument. If the vector is named, the names are
used as argument names.
}
}
\section{Unquoting names}{


When a function takes multiple named arguments
(e.g. \code{dplyr::mutate()}), it is difficult to supply a variable as
name. Since the LHS of \code{=} is quoted, giving the name of a variable
results in the argument having the name of the variable rather than
the name stored in that variable. This problem is right up the
alley for the unquoting operator \code{!!}. If you were able to unquote
the variable when supplying the name, the argument would be named
after the content of that variable.

Unfortunately R is very strict about the kind of expressions
supported on the LHS of \code{=}. This is why we have made the more
flexible \code{:=} operator an alias of \code{=}. You can use it to supply
names, e.g. \code{a := b} is equivalent to \code{a = b}. Since its syntax is
more flexible you can unquote on the LHS:\preformatted{name <- "Jane"

dots_list(!!name := 1 + 2)
exprs(!!name := 1 + 2)
quos(!!name := 1 + 2)
}

Like \code{=}, the \code{:=} operator expects strings or symbols on its LHS.
}

\section{Theory}{


Formally, \code{quo()} and \code{expr()} are quasiquote functions, \code{!!} is
the unquote operator, and \code{!!!} is the unquote-splice operator.
These terms have a rich history in Lisp languages, and live on in
modern languages like
\href{https://docs.julialang.org/en/stable/manual/metaprogramming/}{Julia}
and
\href{https://docs.racket-lang.org/reference/quasiquote.html}{Racket}.
}

\section{Life cycle}{

\itemize{
\item \code{UQ()} and \code{UQS()} were soft-deprecated in rlang 0.2.0 in order
to make the syntax of quasiquotation more consistent. The prefix
forms are now \code{`!!`()} and \code{`!!!`()} which is
consistent with other R operators (e.g. \code{`+`(a, b)} is the
prefix form of \code{a + b}).

Note that the prefix forms are not as relevant as before because
\code{!!} now has the right operator precedence, i.e. the same as
unary \code{-} or \code{+}. It is thus safe to mingle it with other
operators, e.g. \code{!!a + !!b} does the right thing. In addition the
parser now strips one level of parentheses around unquoted
expressions. This way \code{(!!"foo")(...)} expands to \code{foo(...)}.
These changes make the prefix forms less useful.

Finally, the named functional forms \code{UQ()} and \code{UQS()} were
misleading because they suggested that existing knowledge about
functions is applicable to quasiquotation. This was reinforced by
the visible definitions of these functions exported by rlang and
by the tidy eval parser interpreting \code{rlang::UQ()} as \code{!!}. In
reality unquoting is \emph{not} a function call, it is a syntactic
operation. The operator form makes it clearer that unquoting is
special.
\item \code{UQE()} was deprecated in rlang 0.2.0 in order to make the is
deprecated in order to simplify the quasiquotation syntax. You
can replace its use by a combination of \code{!!} and \code{get_expr()}.
E.g. \code{!! get_expr(x)} is equivalent to \code{UQE(x)}.
\item The use of \code{:=} as alias of \code{~} is defunct as of rlang 0.2.0. It
caused surprising results when invoked in wrong places. For
instance in the expression \code{dots_list(name := 1)} this operator
was interpreted as a synonym to \code{=} that supports quasiquotation,
but not in \code{dots_list(list(name := 1))}. Since \code{:=} was an alias
for \code{~} the inner list would contain formula-like object. This
kind of mistakes now trigger an error.
}
}

\examples{
# Quasiquotation functions act like base::quote()
quote(foo(bar))
expr(foo(bar))
quo(foo(bar))

# In addition, they support unquoting:
expr(foo(!!(1 + 2)))
quo(foo(!!(1 + 2)))


# Use `!!!` to add multiple arguments to a function. Its argument
# should evaluate to a list or vector:
args <- list(1:10, na.rm = TRUE)
quo(mean(!!!args))

# You can combine the two
var <- quote(xyz)
extra_args <- list(trim = 0.9, na.rm = TRUE)
quo(mean(!!var , !!!extra_args))


# Unquoting is especially useful for transforming successively a
# captured expression:
quo <- quo(foo(bar))
quo <- quo(inner(!!quo, arg1))
quo <- quo(outer(!!quo, !!!syms(letters[1:3])))
quo

# Since we are building the expression in the same environment, you
# can also start with raw expressions and create a quosure in the
# very last step to record the dynamic environment:
expr <- expr(foo(bar))
expr <- expr(inner(!!expr, arg1))
quo <- quo(outer(!!expr, !!!syms(letters[1:3])))
quo
}
