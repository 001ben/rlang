% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/quo-unquote.R, R/quo.R
\name{UQ}
\alias{UQ}
\alias{UQE}
\alias{!!}
\alias{UQS}
\alias{!!!}
\alias{quosure}
\alias{quo}
\alias{UQ}
\alias{UQE}
\alias{UQS}
\title{Tidy quotation of an expression.}
\usage{
UQ(x)

UQE(x)

"!!"(x)

UQS(x)

quo(expr)
}
\arguments{
\item{x}{An expression to unquote. It is evaluated in the current
environment and inlined in the expression.}

\item{expr}{An expression.}
}
\value{
A formula whose right-hand side contains the quoted
expression supplied as argument.
}
\description{
\code{quo()} captures its argument as an unevaluated expression
and returns it as a formula. Formulas are a key part of the tidy
evaluation framework because they bundle an expression and a scope
(the environment in which \code{quo()} was called).  This means
that you can pass a formula around while keeping track of the
context where it was created. The symbols quoted in the formula
will be evaluated in the right context (where they are likely
defined) by \code{\link[=eval_tidy]{eval_tidy()}}.
}
\details{
Like all capturing functions in the tidy evaluation framework,
\code{quo()} interpolates on capture (see \code{\link[=enquo]{enquo()}} and
\code{vignette("tidy-eval")}). Alternatively, \code{expr_interp()} allows you
to interpolate manually when you have constructed a raw expression
or formula by yourself. When an expression is interpolated, all
sub-expressions within unquoting operators (like \code{UQ(x)} and
\code{UQS(x)}) are evaluated and inlined. This provides a powerful
mechanism for manipulating expressions. Since unquoting is such an
important operation, \code{!!} and \code{!!!} are provided as syntactic
shortcuts for unquoting and unquote-splicing (see examples).
}
\section{Tidy manipulation of expressions}{


Interpolating an expression allows you to inline any value within
the expression. In particular, you can transform a quoted
expression by unquoting another quoted expression into it. The
latter expression gets inlined within the former. This mechanism
allows you to easily program with NSE functions. E.g. \code{var <- ~baz; quo(foo(bar, !! var))} produces the formula-quote
\code{~foo(bar, baz)}.
}

\section{Tidy evaluation of expressions}{


The purpose of a quoted expression is to be eventually evaluated
in a modified scope (e.g. a scope where the columns of a data
frame are directly accessible). While interpolation allows you to
easily manipulate expressions, you need to be a bit careful with
the scope of transplanted subexpressions. If they refer to
variables and functions that are only available in a given
environment (in a given scope), that environment should be
bundled with the expression. That is exactly the purpose of a
one-sided formula: bundling an expression and a scope.

In a way, one-sided formulas are very much similar to promises in
the tidy evaluation framework. Promises are R objects bound to
function arguments which make lazy evaluation in R possible: they
bundle an expression (the argument supplied by the caller of the
function) and an environment (the original call site of the
function), and they self-evaluate to return a value as soon as
you touch them. Similarly, formulas self-evaluate when called
within \code{\link[=eval_tidy]{eval_tidy()}}. However, unlike promises, they are
first-class objects: you can pass a formula around and use it to
transform another formula or expression. Formulas are thus
treated as reified promises.

Being able to manipulate a formula has important practical
purposes: you can create them, inspect them interactively, and
modify them (see previous section). Taken together, tidy
modification and tidy evaluation of formulas provide a powerful
mechanism for metaprogramming and programming with DSLs.
}

\section{Theory}{
 Formally, \code{quo()} and \code{expr()}
are quasiquote functions, \code{UQ()} is the unquote operator, and
\code{UQS()} is the unquote splice operator. These terms have a rich
history in LISP, and live on in modern languages like
\href{http://docs.julialang.org/en/release-0.1/manual/metaprogramming/}{Julia}
and \href{https://docs.racket-lang.org/reference/quasiquote.html}{Racket}.
}

\examples{
# When a tidyeval function captures an argument, it is wrapped in a
# formula and interpolated. quo() is a simple wrapper around
# enquo() and as such is the fundamental tidyeval
# function. It allows you to quote an expression and interpolate
# unquoted parts:
quo(foo(bar))
quo(1 + 2)
quo(paste0(!! letters[1:2], "foo"))

# The !! operator is a syntactic shortcut for unquoting with UQ().
# However you need to be a bit careful with operator
# precedence. All arithmetic and comparison operators bind more
# tightly than `!`:
quo(1 +  !! (1 + 2 + 3) + 10)

# For this reason you should always wrap the unquoted expression
# with parentheses when operators are involved:
quo(1 + (!! 1 + 2 + 3) + 10)

# Or you can use the explicit unquote function:
quo(1 + UQ(1 + 2 + 3) + 10)

# Use !!! or UQS() if you want to add multiple arguments to a
# function It must evaluate to a list
args <- list(1:10, na.rm = TRUE)
quo(mean( UQS(args) ))

# You can combine the two
var <- quote(xyz)
extra_args <- list(trim = 0.9, na.rm = TRUE)
quo(mean(UQ(var) , UQS(extra_args)))


# Unquoting is especially useful for transforming a captured
# expression:
f <- quo(foo(bar))
f <- quo(inner(!! f, arg1))
f <- quo(outer(!! f, !!! lapply(letters[1:3], as_symbol)))
f

# Note that it's fine to unquote expressions to be evaluated as
# quosures, as long as you evaluate with eval_tidy():
f <- quo(letters)
f <- quo(toupper(!! f))
eval_tidy(f)

# Quosures carry scope information about the inner expression
# inlined in the outer expression upon unquoting. To see this,
# let's create a quosure that quotes a symbol that only exists in a
# local scope (a child environment of the current environment):
f1 <- locally({ foo <- "foo"; quo(foo) })

# You can evaluate that expression with eval_tidy():
eval_tidy(f1)

# And you can also inline it in another expression before
# evaluation:
f2 <- locally({ bar <- "bar"; quo(toupper(bar))})
f3 <- quo(paste(!!f1, !!f2, "!"))
f3

# eval_tidy() treats quosures as promises to be evaluated:
eval_tidy(f3)


# Quoting as a quosure is necessary to preserve scope information
# and make sure objects are looked up in the right place. However,
# there are situations where it can get in the way. This is the
# case when you deal with non-tidy NSE functions that do not
# understand formulas. You can inline the RHS of a formula in a
# call thanks to the UQE() operator:
nse_function <- function(arg) substitute(arg)
var <- locally(quo(foo(bar)))
quo(nse_function(UQ(var)))
quo(nse_function(UQE(var)))

# This is equivalent to unquoting and taking the RHS:
quo(nse_function(!! get_expr(var)))

# One of the most important old-style NSE function is the dollar
# operator. You need to use UQE() for subsetting with dollar:
var <- quo(cyl)
quo(mtcars$UQE(var))

# `!!`() is also treated as a shortcut. It is meant for situations
# where the bang operator would not parse, such as subsetting with
# $. Since that's its main purpose, we've made it a shortcut for
# UQE() rather than UQ():
var <- quo(cyl)
quo(mtcars$`!!`(var))


# Quosures are represented as formulas, but formulas are not
# treated identically to quosures. Formulas are guarded on capture
# so that they evaluate to a literal formula rather than
# self-evaluate like quosures:
quo_f <- ~letters[1:2]
quo <- quo(letters[1:2])

f <- quo(list(!!quo_f, !! quo))
f
eval_tidy(f)


# When a quosure is printed in the console, the brackets indicate
# if the enclosure is the global environment or a local one:
locally(quo(foo))

# Literals are enquosed with the empty environment because they can
# be evaluated anywhere:
quo(10L)

# To differentiate local environments, use str(). It prints the
# machine address of the environment:
quo1 <- locally(quo(foo))
quo2 <- locally(quo(foo))
quo1; quo2
str(quo1); str(quo2)
}
\seealso{
\link[=quosures]{quos()} for capturing several expressions,
including from dots; \code{\link[=expr]{expr()}} for quoting a raw
expression with quasiquotation; and \code{\link[=expr_interp]{expr_interp()}} for unquoting
an already quoted expression or an existing formula.
}
