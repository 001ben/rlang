% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/types.R
\name{switchpatch}
\alias{switchpatch}
\title{Dispatch on base types.}
\usage{
switchpatch(.x, ..., .to)
}
\arguments{
\item{.x}{An object from which to dispatch.}

\item{...}{Named clauses. The names should be types as returned by
\code{\link[=type_of]{type_of()}}.}

\item{.to}{This is useful when you switchpatch in a coercing
function. If supplied, this should be a string indicating the
target type. A catch-all clause is then added to signal an error
stating the conversion failure.}
}
\description{
This is equivalent to
\code{\link[base]{switch}(\link{type_of}(x, ...))}.
}
\examples{
switchpatch(3L,
  double = "foo",
  integer = "bar",
  "default"
)

# Strings have their own type:
switchpatch("string",
  character = "foo",
  string = "bar",
  "default"
)

# Use a fallthrough clause if you need to dispatch on all character
# vectors, including strings:
switchpatch("string",
  string = ,
  character = "foo",
  "default"
)

# special and builtin functions are treated as primitive, since
# there is usually no reason to treat them differently:
switchpatch(base::list,
  primitive = "foo",
  "default"
)
switchpatch(base::`$`,
  primitive = "foo",
  "default"
)

# closures are not primitives:
switchpatch(rlang::switchpatch,
  primitive = "foo",
  "default"
)
}
